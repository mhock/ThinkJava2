\chapter{Keyboard input and interaction}

Although our programs have gotten progressively more complicated, they have not been interactive in any way. This chapter will show you how to read input from the keyboard, use that input to calculate a result, and then format that result for output. We'll also take a first look at \java{String} methods and solve some interesting problems.

%We will also look at some technical details about how operating systems work.


\section{Characters}

Some of the most interesting problems in computer science involve searching and manipulating text.
In the next few sections, we'll discuss how to apply loops to strings.
Although the examples are short, the techniques work the same whether you have one word or one million words.

\index{charAt}
\index{char}
\index{type!char}

Strings provide a method named \java{charAt}.
It returns a \java{char}, a data type that stores an individual character (as opposed to strings of them).

\begin{code}
	String fruit = "banana";
	char letter = fruit.charAt(0);
\end{code}

The argument \java{0} means that we want the character at {\bf index} 0.
String indexes range from 0 to $n-1$, where $n$ is the length of the string.
So the character assigned to \java{letter} is \java{b}.

\begin{center}
	\ttfamily
	\begin{tabular}{cccccc}
		\hline
		\multicolumn{1}{|l|}{b} & \multicolumn{1}{l|}{a} & \multicolumn{1}{l|}{n} & \multicolumn{1}{l|}{a} & \multicolumn{1}{l|}{n} & \multicolumn{1}{l|}{a} \\ \hline
		0                       & 1                      & 2                      & 3                      & 4                      & 5
	\end{tabular}
\end{center}


Characters work like the other data types we have seen.
You can compare them using relational operators:

\begin{code}
	if (letter == 'a') {
		System.out.println('?');
	}
\end{code}

\index{quote mark}
\index{escape sequence}

Character literals, like \java{'a'}, appear in single quotes.
Unlike string literals, which appear in double quotes, character literals can only contain a single character.
Escape sequences, like \java{'\\t'}, are legal because they represent a single character.

The increment and decrement operators also work with characters.
So this loop displays the letters of the alphabet:

\begin{code}
	System.out.print("Roman alphabet: ");
	for (char c = 'A'; c <= 'Z'; c++) {
		System.out.print(c);
	}
	System.out.println();
\end{code}

\index{Unicode}

Java uses {\bf Unicode} to represent characters, so strings can store text in other alphabets like Cyrillic and Greek, and non-alphabetic languages like Chinese.
You can read more about it at \url{http://unicode.org/}.

In Unicode, each character is represented by a ``code point'', which you can think of as an integer.
The code points for uppercase Greek letters run from 913 to 937, so we can display the Greek alphabet like this:

\begin{code}
	System.out.print("Greek alphabet: ");
	for (int i = 913; i <= 937; i++) {
		System.out.print((char) i);
	}
	System.out.println();
\end{code}

This example uses a type cast to convert each integer (in the range) to the corresponding character.
Try running the code and see what happens.

Most Unicode characters require only one code point, but emoji and some others require multiple code points, meaning they can't be stored in a single \java{char}. In addition, some characters can be represented in more than one way. For example, \'a (lowercase a with acute accent) can be encoded as code point 225, or as the sequence 97 (lowercase a) followed by 769 (acute accent). Both encodings will draw the same visual representation \'a.

\section{The System class}

\index{class!System}

We have been using \java{System.out.println} for a while, but you might not have thought about what it means.
\java{System} is a class that provides methods related to the ``system'' or environment where programs run.
It also provides \java{System.out}, which is a special value that has additional methods (like \java{println}) for displaying output.

\index{System.out}

In fact, we can use \java{System.out.println} to display the value of \java{System.out}:

\begin{code}
System.out.println(System.out);
\end{code}

The result is:

\begin{stdout}
java.io.PrintStream@685d72cd
\end{stdout}

\index{package}
\index{java.io}

This output indicates that \java{System.out} is a \java{PrintStream}, which is defined in a package called \java{java.io}.
A {\bf package} is a collection of related classes; \java{java.io} contains classes for ``I/O'' which stands for input and output.

\index{address}
\index{hexadecimal}

The numbers and letters after the {\tt @} sign are the {\bf hash code} of \java{System.out}, represented as a hexadecimal (base 16) number.
The hash code is related to the memory location where the object is being stored.
In this example the hash code is \java{685d72cd}, but if you run the same code you will likely get something else.

\index{library}

As shown in Figure~\ref{fig.system}, \java{System} is defined in a file called {\tt System.java}, and \java{PrintStream} is defined in {\tt PrintStream.java}.
These files are part of the Java {\bf library}, which is an extensive collection of classes that you can use in your programs.
The source code for these classes is usually included with the compiler (see Section~\ref{src.zip}).

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/system.pdf}
\caption{\java{System.out.println} refers to the \java{out} variable of the \java{System} class, which is a \java{PrintStream} that provides a method called \java{println}.}
\label{fig.system}
\end{center}
\end{figure}


\section{The Scanner class}
\label{scanner}

\index{Scanner}
\index{class!Scanner}

%\index{byte}
%
%From the operating system's point of view, data from the keyboard arrives in a series of hardware control signals.
%The operating system translates these signals into a stream of {\bf bytes} (small integers), which in turn need to be translated into characters.
%\java{System.in} provides the means for reading one byte of input at a time, which is hardly useful for programs that would rather read in an entire word or line of input.

\index{System.in}

The \java{System} class also provides the special value \java{System.in}, which is an \java{InputStream} that has methods for reading input from the keyboard.
These methods are not convenient to use, but fortunately Java provides other classes that make it easy to handle common input tasks.

\index{class!utility}
\index{utility class}
\index{java.util}

For example, \java{Scanner} is a class that provides methods for inputting words, numbers, and other data.
\java{Scanner} is provided by \java{java.util}, which is a package that contains various ``utility classes''.
Before you can use \java{Scanner}, you have to import it like this:

\begin{code}
import java.util.Scanner;
\end{code}

\index{import statement}
\index{statement!import}

This {\bf import statement} tells the compiler that when you refer to \java{Scanner}, you mean the one defined in \java{java.util}.
Using an import statement is necessary because there might be another class named \java{Scanner} in another package.
%Using an import statement makes your code unambiguous.
Import statements can't be inside a class definition.
By convention, they are usually at the beginning of the file.

Next you have to initialize the \java{Scanner}.
This line declares a \java{Scanner} variable named \java{in} and creates a \java{Scanner} that reads input from \java{System.in}:
%We'll explain the \java{new} operator in more detail in Section~\ref{point}.

\begin{code}
Scanner in = new Scanner(System.in);
\end{code}

The \java{Scanner} class provides a method called \java{nextLine} that reads a line of input from the keyboard and returns a \java{String}.
The following example reads two lines and repeats them back to the user:

\index{Echo.java}

\begin{trinket}{Echo.java}
import java.util.Scanner;

public class Echo {

    public static void main(String[] args) {
        String line;
        Scanner in = new Scanner(System.in);

        System.out.print("Type something: ");
        line = in.nextLine();
        System.out.println("You said: " + line);

        System.out.print("Type something else: ");
        line = in.nextLine();
        System.out.println("You also said: " + line);
    }
}
\end{trinket}

If you omit the import statement at the top of the file, you will get a compiler error saying ``cannot find symbol''.
That means the compiler doesn't know where to find the definition for \java{Scanner}.

\index{java.lang}

You might wonder why we can use the \java{System} class without importing it.
\java{System} belongs to the \java{java.lang} package, which is imported automatically.
According to the documentation, \java{java.lang} ``provides classes that are fundamental to the design of the Java programming language.''
The \java{String} class is also part of the \java{java.lang} package.


\section{Language elements}

\index{language!elements}

At this point, we have seen nearly all of the organizational units that make up Java programs.
Figure~\ref{fig.package} shows how these ``language elements'' are related.

\begin{figure}[!ht]
\begin{center}
\includegraphics[width=4in]{figs/package.pdf}
\caption{Elements of the Java language, from largest to smallest.}
\label{fig.package}
\end{center}
\end{figure}

\index{token}

Java applications are typically organized into packages (like \java{java.io} and \java{java.util}) that include multiple classes (like \java{PrintStream} and \java{Scanner}).
Each class defines its own methods (like \java{println} and \java{nextLine}), and each method is a sequence of statements.

Each statement performs one or more computations, depending on how many expressions it has, and each expression represents a single value to compute.
For example, the assignment statement \java{hours = minutes / 60.0;} contains a single expression: \java{minutes / 60.0}.

{\bf Tokens} are the most basic elements of a program, including numbers, variable names, operators, keywords, parentheses, braces, and semicolons.
In the previous example, the tokens are \java{hours}, \java{=}, \java{minutes}, \java{/}, \java{60.0}, and \java{;} (spaces are ignored by the compiler).

%\index{syntax}
%\index{semantics}

Knowing this terminology is helpful, because error messages often say things like ``not a statement'' or ``illegal start of expression'' or ``unexpected token''.
Comparing Java to English, statements are complete sentences, expressions are phrases, and tokens are individual words and punctuation marks.

Note there is a big difference between the Java {\em language}, which defines the elements in Figure~\ref{fig.package}, and the Java {\em library}, which provides the built-in classes that you can import.
For example, the keywords \java{public} and \java{class} are part of the Java language, but the names \java{PrintStream} and \java{Scanner} are not.

The standard edition of Java comes with {\em several thousand} classes you can use, which can be both exciting and intimidating.
You can browse this library at \url{http://docs.oracle.com/javase/8/docs/api/}.
Interestingly, most of the Java library is written in Java.

\section{Unit conversion revisited}

Here is a simple interactive program which converts centimeters to feet and inches:

\index{Convert.java}

\begin{trinket}{Convert.java}
import java.util.Scanner;

/**
 * Converts centimeters to feet and inches.
 */
public class Convert {

    public static void main(String[] args) {
        double cm;
        int feet, inches, remainder;
        final double CM_PER_INCH = 2.54;
        final int IN_PER_FOOT = 12;
        Scanner in = new Scanner(System.in);

        // prompt the user and get the value
        System.out.print("Exactly how many cm? ");
        cm = in.nextDouble();

        // convert and output the result
        inches = (int) (cm / CM_PER_INCH);
        feet = inches / IN_PER_FOOT;
        remainder = inches % IN_PER_FOOT;
        System.out.printf("%.2f cm = %d ft, %d in\n",
                          cm, feet, remainder);
    }
}
\end{trinket}

Although not required, all variables and constants are declared at the top of \java{main}.
This practice makes it easier to find their types later on, and it helps the reader know what data is involved in the algorithm.

\index{documentation}

For readability, each major step of the algorithm is separated by a blank line and begins with a comment.
The class also includes a documentation comment (\java{/**}), which you can learn more about in Appendix~\ref{javadoc}.

Many algorithms, including the \java{Convert} program, perform division and modulo together.
In both steps, you divide by the same number (\java{IN_PER_FOOT}).

When statements including \java{System.out.printf} get long (generally wider than 80 characters), a common style convention is to break them across multiple lines.
The reader should never have to scroll horizontally.


\section{The Scanner bug}
\label{mutablescanner}
Now that you've had some experience with \java{Scanner}, there is an unexpected behavior we want to warn you about.
The following code fragment asks users for their name and age:

\begin{code}
System.out.print("What is your name? ");
name = in.nextLine();
System.out.print("What is your age? ");
age = in.nextInt();
System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

The output might look something like this:

\begin{stdout}
Hello Grace Hopper, age 45
\end{stdout}

When you read a \java{String} followed by an \java{int}, everything works just fine.
But when you read an \java{int} followed by a \java{String}, something strange happens.

\begin{code}
System.out.print("What is your age? ");
age = in.nextInt();
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

Try running this example code.
It doesn't let you input your name, and it immediately displays the output:

\begin{stdout}
What is your name? Hello , age 45
\end{stdout}

To understand what is happening, you need to realize that \java{Scanner} doesn't see input as multiple lines like we do.
Instead, it gets a ``stream of characters'' as shown in Figure~\ref{fig.hopper1}.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/hopper1.pdf}
\caption{A stream of characters as seen by a \java{Scanner}.}
\label{fig.hopper1}
\end{center}
\end{figure}

%TODO define call/invoke or use other term?

The arrow indicates the next character to be read by \java{Scanner}.
When you call \java{nextInt}, it reads characters until it gets to a non-digit.
Figure~\ref{fig.hopper2} shows the state of the stream after \java{nextInt} is called.

\begin{figure}[!ht]
\begin{center}
\includegraphics{figs/hopper2.pdf}
\caption{A stream of characters after \java{nextInt} is called.}
\label{fig.hopper2}
\end{center}
\end{figure}

At this point, \java{nextInt} returns \java{45}.
The program then displays the prompt \java{"What is your name? "} and calls \java{nextLine}, which reads characters until it gets to a newline.
But since the next character is already a newline, \java{nextLine} returns the empty string \java{""}.

To solve this problem, you need an extra \java{nextLine} after \java{nextInt}.

\begin{code}
System.out.print("What is your age? ");
age = in.nextInt();
in.nextLine();  // read the newline
System.out.print("What is your name? ");
name = in.nextLine();
System.out.printf("Hello %s, age %d\n", name, age);
\end{code}

This technique is common when reading \java{int} or \java{double} values that appear on their own line.
First you read the number, and then you read the rest of the line, which is just a newline character.

\section{Validating input}
\label{validate}

\index{validate}
\index{hacker}

One of the most important tasks in any computer program is to {\bf validate} input from the user.
People often make mistakes while typing, especially on smartphones, and incorrect inputs may cause your program to fail.

Even worse, someone (i.e., a {\bf hacker}) may intentionally try to break into your system by entering unexpected inputs.
You should never assume that users will input the right kind of data.

Consider this simple program that prompts the user for a number and computes its logarithm:

\begin{code}
	Scanner in = new Scanner(System.in);
	System.out.print("Enter a number: ");
	double x = in.nextDouble();
	double y = Math.log(x);
	System.out.println("The log is " + y);
\end{code}

In mathematics, the natural logarithm (base $e$) is undefined when $x < 0$.
If you ask for \java{Math.log(-1)}, it will return {\bf NaN} which stands for ``not a number''.
Many users are confused when they see NaN; it often looks like a bug.
We can use an \java{if} statement to make the output more user friendly.

\begin{code}
	if (x >= 0) {
		double y = Math.log(x);
		System.out.println("The log is " + y);
	} else {
		System.out.println("The log is undefined");
	}
\end{code}

The output is better now, but there is another problem.
What if the user doesn't enter a number at all?
What would happen if they typed the word ``hello'', either on accident or on purpose?

\index{InputMismatchException}
\index{exception!InputMismatch}

\begin{small}
	\begin{stdout}
		Exception in thread "main" java.util.InputMismatchException
		at java.util.Scanner.throwFor(Scanner.java:864)
		at java.util.Scanner.next(Scanner.java:1485)
		at java.util.Scanner.nextDouble(Scanner.java:2413)
		at Logarithm.main(Logarithm.java:8)
	\end{stdout}
\end{small}

\index{run-time error}
\index{testing}

If the user inputs a \java{String} when we expect a \java{double}, Java reports an ``input mismatch'' exception.
We can prevent this run-time error from happening by testing the input first.

The \java{Scanner} class provides \java{hasNextDouble}, which checks whether the next input can be interpreted as a \java{double}.
If not, we can display an error message.

\begin{code}
	if (!in.hasNextDouble()) {
		String word = in.next();
		System.err.println(word + "is not a number");
		return;
	}
\end{code}

\index{next!Scanner}

In contrast to \java{in.nextLine}, which returns an entire line of input, the \java{in.next} method returns only the next token of input.
We can use \java{in.next} to show the user exactly which word they typed was not a number.

\index{System.err}

This example also uses \java{System.err}, which is an \java{OutputStream} for error messages and warnings.
Some development environments display output to \java{System.err} with a different color or in a separate window.

\index{return}
\index{statement!return}

The \java{return} statement allows you to exit a method before you reach the end of it.
Returning from \java{main} terminates the program.

Notice the use of the \java{!} operator before \java{in.hasNextDouble()}, instead of testing the condition \java{in.hasNextDouble() == false}.
Since \java{hasNextDouble} returns a boolean, it is already a condition.


\section{Example program}

In this chapter we have seen relational and logical operators, \java{if} statements, the \java{Math} class, and validating input.
The following program shows how the individual code examples in the last section fit together.

\index{Logarithm.java}

\begin{trinket}{Logarithm.java}
	import java.util.Scanner;
	
	/**
	* Demonstrates input validation using if statements.
	*/
	public class Logarithm {
		
		public static void main(String[] args) {
			
			// prompt for input
			Scanner in = new Scanner(System.in);
			System.out.print("Enter a number: ");
			
			// check the format
			if (!in.hasNextDouble()) {
				String word = in.next();
				System.err.println(word + " is not a number");
				return;
			}
			
			// check the range
			double x = in.nextDouble();
			if (x >= 0) {
				double y = Math.log(x);
				System.out.println("The log is " + y);
			} else {
				System.out.println("The log is undefined");
			}
		}
	}
\end{trinket}

What started as five lines of code at the beginning of Section~\ref{validate} is now a 30-line program.
Making programs robust (and secure) often requires a lot of additional checking, as shown in this example.

\section{Creating an interactive game}

We have learned enough to create an interactive game. We'll use a game that doesn't require the computer to have any kind of intelligence, but it will use randomness to create an initial problem to solve.

\subsection{Code guessing game}
\label{guesscode}
Let's say you are trying to guess a secret code. The code has $m$ digits. In addition, you know each digit is in the range 1 through $n$. Repeat digits are allowed and the order matters. For example, if $m=4$ and $n=6$, the following are some possible codes: $1234,6666,1122,1212,2211$. Notice that the digit 0 is not allowed in this game.

When you guess a code, you are given some feedback. You are told how many of your digits are {\em perfect}: the number of digits that match in the same position in your guess and the secret code. (If all $m$ of your digits are perfect, you win!) You are also told how many of your digits are {\em close}: the number of digits that are in the secret code and your guess, but in a different position in your guess than in the secret code.
For example, if the secret code is $1123$ and you guess $2213$, you would be told that one of your digits is perfect and two of your digits are close. (The 3 is in the correct position. One of your 2s matches a 2 in the code, and your 1 matches one of the 1s in the code. Notice that you don't count two matches for your 2s because there is only one 2 in the secret code to match against!)

\subsection{Randomness}
\label{randomness}
The \java{Math.random()} method returns a random \java{double} between 0.0 and 1.0. The number can be as small as 0 but it can never quite be 1 (it ends up being about 0.9999999999999999). If we take this number, multiply it by an \java{int} $n$, then cast the result to \java{int}, we end up with an integer in the range $[0,n-1]$ with roughly equal chances for each number. {\em Pay close attention to the use of parentheses below. Without parentheses, \java{Math.random()} would be cast to \java{int} which would always evaluate to 0.}


\subsection{Creating a secret code}

We can write a static method to create a secret code as an array of digits.
\begin{code}
public static int[] createSecretCode(int length, int range) {
	int[] code = new int[length];
	for (int i = 0; i < length; i++) {
		code[i] = (int)(Math.random() * range) + 1;
	}
	return code;
}
\end{code}

\subsection{Converting an \java{int} to an array}

It was convenient to work with an array of digits. When a user types an integer as a guess, we want to break it up into an array of digits. The easiest way to do this is to use the remainder operator \java{\%} to get the ones digit and divide to remove the ones digit. However, because the ones digit is the one on the right, we must fill in the array {\em from right to left}.

\begin{code}
public static int[] guessToArray(int guess, int length, int range) {
	int[] a = new int[length];
	for (int i = length-1; i >= 0; i--) {
		a[i] = guess % 10;
		if (a[i] < 1 || a[i] > range) {
			return null; // make sure the digits are not too small or big
		}
		guess /= 10; // Divide away the ones digit
	}
	if (guess != 0) return null; // make sure the guess matches the length
	return a;
}
\end{code}

\subsection{Comparing a secret code to a guess}

We can write a static method to count the number of perfect digits in a guess, one at a time:

\begin{code}
public static int countPerfect(int[] secret, int[] guess) {
	int count = 0;
	for (int i = 0; i < secret.length; i++) {
		if (secret[i] == guess[i]) count++;
	}
	return count;
}
\end{code}

\subsection{Advanced: Close digit method}

In order to count the number of {\em close} digits, we must keep track of which digits have been matched. We can use a boolean array for each digit of the secret code array which tracks whether a secret digit has been matched. We must also keep from matching a guess digit twice and skip any perfect digits.

\begin{code}
public static int countClose(int[] secret, int[] guess) {
	boolean[] matched = new boolean[secret.length];
	int count = 0;
	for (int i = 0; i < guess.length; i++) {
		if (guess[i] == secret[i]) continue; // Skip perfect
		for (int j = 0; j < secret.length; j++) {
			// Skip matched and perfect digits in secret code
			if (matched[j] || guess[j] == secret[j]) continue;
			if (guess[i] == secret[j]]) { // We found a match!
				matched[j] = true;
				count++;
				break; // Prevent multiple matches
			}
		}
	}
	return count;
}
\end{code}

\subsection{Writing an interactive main method}

We can use a Scanner along with the above methods to create an interactive game. Review section~\ref{mutablescanner} for more information on the "Scanner bug".

\begin{code}
// Make sure your class imports java.util.Scanner.
public static void main(String[] args) {
	int length = 4; // 4 digit code
	int range = 6; // each digit in the range 1-6
	Scanner s = new Scanner(System.in);
	int[] secret = createSecretCode(length, range);
	int[] guess = new int[length];
	while (countPerfect(secret, guess) != length) {
		guess = null;
		while (guess == null) {
			System.out.print("Please enter a guess (" + length
				+ " digits in the range 1-"+range+"): ");
			if (s.hasNextInt()) {
				guess = guessToArray(s.nextInt(), length, range);
			}
			s.nextLine(); // "Scanner bug"
		}
		System.out.println("You have " + countPerfect(secret, guess)
			+ " perfect digit(s) and "+countClose(secret, guess)
			+ " close digit(s).";
	}
	System.out.println("You win!")
}
\end{code}

% DW suggests we also cover PrintWriter to write files --
% add an appendix on File I/O since it involves try/catch?

\section{Vocabulary}

\begin{description}

\term{index}
An integer variable or value used to indicate a character in a string.

\term{Unicode}
An international standard for representing characters in most of the world's languages.

\term{empty string}
The string \java{""}, which contains no characters and has a length of zero.

\term{package}
A directory of classes that are related to each other.
%Java classes are organized into packages.

\term{address}
The location of a value in computer memory, often represented as a hexadecimal integer.

\term{library}
A collection of packages and classes that are available for use in other programs.
%Libraries are often distributed in {\tt .jar} (Java Archive) files.

%\term{abstraction}
%The process of reducing information and/or detail to focus on high-level concepts.

%\term{operating system}
%Software that is always running behind the scenes on your computer.
%It controls the execution of application programs and manages hardware resources.

%\term{byte}
%A single unit of data on a computer; enough to represent one character.

%\term{utility class}
%A class that provides commonly needed functionality.

\term{import statement}
A statement that allows programs to use classes defined in other packages.

\term{token}
The smallest unit of source code, such as an individual word, literal value, or symbol.

%\term{syntax}
%The structure of a program; the arrangement of the words and symbols it contains.

%\term{semantics}
%The meaning of a program; the low-level instructions it should perform.

\term{literal}
A value that appears in source code.
For example, \java{"Hello"} is a string literal, and \java{74} is an integer literal.

\term{prompt}
A brief message displayed in a print statement that asks the user for input.

\term{magic number}
A number that appears without explanation as part of an expression.
It should generally be replaced with a constant.

\term{constant}
A variable, declared as \java{final}, whose value cannot be changed.

\term{format string}
The string in \java{System.out.printf} that specifies the format of the output.

\term{format specifier}
A special code that begins with a percent sign and specifies the data type and format of the corresponding value.

\term{type cast}
An operation that explicitly converts one data type into another.
In Java it appears as a type name in parentheses, like \java{(int)}.

%\term{truncate}
%To make shorter by cutting something off.
%Casting a floating-point value to an integer simply removes the fractional part.

\term{modulo}
An operation that yields the remainder when one integer is divided by another.
In Java, it is denoted with a percent sign: \java{5 \% 2} is \java{1}.

\term{modulus}
The value of \java{b} in the expression \java{a \% b}.
It often represents unit conversions, such as 24 hours in a day, 60 minutes in an hour, etc.

\term{NaN}
A special floating-point value that stands for ``not a number''.

\end{description}


\section{Exercises}

The code for this chapter is in the {\tt ch03} directory of {\tt ThinkJavaCode2}.
See page~\pageref{code} for instructions on how to download the repository.
Before you start the exercises, we recommend that you compile and run the examples.

If you have not already read Appendix~\ref{commandline}, now might be a good time.
It describes the command-line interface, which is a powerful and efficient way to interact with your computer.

\begin{exercise}  %%V6 Ex9.5

\index{abecedarian}

A word is said to be ``abecedarian'' if the letters in the word appear in alphabetical order.
For example, the following are all six-letter English abecedarian words:

\begin{quote}
abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, %\\
beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, %\\
deinos, diluvy, dimpsy %\\
\end{quote}

Write a method called \java{isAbecedarian} that takes a \java{String} and returns a \java{boolean} indicating whether the word is abecedarian.
%Your method can be iterative or recursive.

\end{exercise}


\begin{exercise}  %%V6 Ex9.8

\index{Scrabble}

In Scrabble\footnote{Scrabble is a registered trademark owned in the USA and Canada by Hasbro Inc., and in the rest of the world by J.\ W.\ Spear \& Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.} each player has a set of tiles with letters on them.
The object of the game is to use those letters to spell words.
The scoring system is complex, but longer words are usually worth more than shorter words.

Imagine you are given your set of tiles as a string, like \java{"quijibo"}, and you are given another string to test, like \java{"jib"}.

Write a method called \java{canSpell} that takes two strings and checks whether the set of tiles can spell the word.
You might have more than one tile with the same letter, but you can only use each tile once.

\end{exercise}

\begin{exercise}  %%V6 Ex9.2
	
	Write a method called \java{letterHist} that takes a string as a parameter and returns a histogram of the letters in the string.
	The zeroth element of the histogram should contain the number of a's in the string (upper- and lowercase); the 25th element should contain the number of z's.
	Your solution should only traverse the string once.
	
\end{exercise}


\begin{exercise}  %%V6 Ex9.7
	
	\index{anagram}
	
	Two words are anagrams if they contain the same letters and the same number of each letter.
	For example, ``stop'' is an anagram of ``pots'' and ``allen downey'' is an anagram of ``well annoyed''.
	Write a method that takes two strings and checks whether they are anagrams of each other.
	
\end{exercise}

\begin{exercise}  %%V6 Ex3.1

When you use \java{printf}, the Java compiler does not check your format string.
See what happens if you try to display a value with type \java{int} using \java{\%f}.
And what happens if you display a \java{double} using \java{\%d}?
What if you use two format specifiers, but then only provide one value?

\end{exercise}

%If you try to print an integer with \java{\%f} or a floating-point number using \java{\%d}, you get an \java{IllegalFormatConversionException}.


\begin{exercise}  %%V6 Ex3.2

Write a program that converts a temperature from Celsius to Fahrenheit.
It should (1) prompt the user for input, (2) read a \java{double} value from the keyboard, (3) calculate the result, and (4) format the output to one decimal place.
For example, it should display {\tt "24.0 C = 75.2 F"}.

Here is the formula.
Be careful not to use integer division!
%
\[ F = C \times \frac{9}{5} + 32 \]

\end{exercise}


\begin{exercise}  %%V6 Ex3.3

Write a program that converts a total number of seconds to hours, minutes, and seconds.
It should (1) prompt the user for input, (2) read an integer from the keyboard, (3) calculate the result, and (4) use \java{printf} to display the output.
For example, {\tt "5000 seconds = 1 hours, 23 minutes, and 20 seconds"}.

{\it Hint:} Use the remainder operator.

\end{exercise}


\begin{exercise}  %%V6 Ex3.4
\label{guess}

The goal of this exercise is to program a ``Guess My Number'' game.
When it's finished, it will work like this:

\begin{stdout}
I'm thinking of a number between 1 and 100
(including both). Can you guess what it is within 8 guesses?
Type a number: 45
My number is smaller!
You have 7 guesses remaining.
Type a number: six
You must enter a decimal integer number between 1 and 100.
Type a number: 6
My number is larger!
You have 6 guesses remaining.
Type a number: 14
You guessed my number!
\end{stdout}

\index{new}
\index{operator!new}

\begin{enumerate}

\item Start with the following code. Refer to section~\ref{randomness} for more information on randomness.

\index{GuessStarter.java}
\label{guessstarter}

\begin{trinket}{GuessStarter.java}
	
	public class GuessStarter {		
		public static void main(String[] args) {
			// pick a random number
			int number = (int)(Math.random() * 100) + 1;
			System.out.println(number);
		}
	}
\end{trinket}


\item The definition of \java{GuessStarter} is in a file called {\tt GuessStarter.java}, in the directory called {\tt ch03}, in the repository for this book.
%Instructions for downloading this code are on page~\pageref{code}.

\item Compile and run this program.

\item Modify the program to prompt the user, then use a \java{Scanner} to read a line of user input.
Compile and test the program.

\item Read the user input as an integer and compute and display whether the user's guess is greater than, less than, or equal to the number that was generated.

\item Prevent the user from typing a guess which is out of range or not an integer. Use the technique we learned from the code guessing game in section~\ref{guesscode}

\item Use a loop to allow the user to make multiple guesses and track the remaining guesses. Exit the loop if the user guesses correctly. If the user doesn't guess the number, print the following message:
\begin{stdout}
The number I was thinking of is: 14
Better luck next time.	
\end{stdout}


\end{enumerate}

\end{exercise}
